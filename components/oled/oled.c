#include <string.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"

#include "oled.h"
#include "hw.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ==== SSD130x low-level ====
static spi_device_handle_t s_oled;
static SemaphoreHandle_t s_oled_lock = NULL;

static inline void dc_cmd(void){
    gpio_set_level(PIN_DC_OLED, 0);
}
static inline void dc_data(void){
    gpio_set_level(PIN_DC_OLED, 1);
}

static void tx(const void* data, size_t len, bool is_data){
    if (!s_oled_lock) {
        static StaticSemaphore_t buf;
        s_oled_lock = xSemaphoreCreateMutexStatic(&buf);
    }
    if (s_oled_lock) xSemaphoreTake(s_oled_lock, portMAX_DELAY);

    spi_transaction_t t = {0};
    t.length = len * 8;
    t.tx_buffer = data;
    if (is_data) dc_data(); else dc_cmd();
    (void)spi_device_transmit(s_oled, &t);

    if (s_oled_lock) xSemaphoreGive(s_oled_lock);
}
static inline void cmd1(uint8_t c){ tx(&c, 1, false); }
static inline void cmd2(uint8_t c, uint8_t v){ uint8_t b[2]={c,v}; tx(b, 2, false); }

static inline void fb_pset(uint8_t *fb, int x, int y){
    if ((unsigned)x >= PANEL_W || (unsigned)y >= PANEL_H) return;
    int idx = y * PANEL_W + x;
    fb[idx >> 3] |= (uint8_t)(1u << (7 - (idx & 7)));
}

static void hw_reset(void){
    if (PIN_RST_OLED == GPIO_NUM_NC) return;
    gpio_set_level(PIN_RST_OLED, 0);
    vTaskDelay(pdMS_TO_TICKS(10));
    gpio_set_level(PIN_RST_OLED, 1);
    vTaskDelay(pdMS_TO_TICKS(10));
}

static inline void begin_window(int x0, int x1, int page0, int page1){
    cmd1(0x21); cmd1(x0); cmd1(x1);
    cmd1(0x22); cmd1(page0); cmd1(page1);
}

// ==== Public API ====
void oled_init(void)
{
    // Shared SPI2 bus
    ESP_ERROR_CHECK(hw_spi2_init_once());
    vTaskDelay(pdMS_TO_TICKS(100));  // power-on settle

    // DC / CS (/RST) as outputs
    gpio_config_t io = {
        .pin_bit_mask = (1ULL << PIN_DC_OLED)
                      | (1ULL << PIN_CS_OLED)
                      | ((PIN_RST_OLED != GPIO_NUM_NC) ? (1ULL << PIN_RST_OLED) : 0),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = 0,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&io);
    gpio_set_level(PIN_DC_OLED, 0);

    // Attach device on shared bus â€” mode 0
    spi_device_handle_t dev = NULL;
    ESP_ERROR_CHECK(hw_spi2_add_oled(&dev));
    s_oled = dev;

    hw_reset();

    // SSD1306/1309 init (128x64)
    cmd1(0xAE);                  // display off
    vTaskDelay(pdMS_TO_TICKS(2));
    cmd2(0xD5, 0x80);            // clock div
    cmd2(0xA8, PANEL_H - 1);     // multiplex
    cmd2(0xD3, 0x00);            // offset
    cmd1(0x40);                  // start line (0)
    cmd2(0x8D, 0x14);            // charge pump on (works for most SSD1306/1309 boards)
    cmd2(0x20, 0x00);            // memory mode: horizontal
    cmd1(0xA1);                  // seg remap
    cmd1(0xC8);                  // COM scan dec
    cmd2(0xDA, (PANEL_H==64)?0x12:0x02); // COM pins
    cmd2(0x81, 0xCF);            // contrast
    cmd2(0xD9, 0xF1);            // precharge
    cmd2(0xDB, 0x40);            // VCOM detect
    cmd1(0xA4);                  // resume from all-on
    cmd1(0xA6);                  // normal display
    cmd1(0xAF);                  // display ON
    vTaskDelay(pdMS_TO_TICKS(50)); // let panel wake up
}


void oled_clear(void){
    begin_window(0, PANEL_W-1, 0, (PANEL_H/8)-1);
    static uint8_t zeros[128] = {0};
    for (int page=0; page<PANEL_H/8; ++page){
        tx(zeros, PANEL_W, true);
    }
}

// ---- Full-screen 128x64 blit (buf is PANEL_W*PANEL_H/8) ----
void oled_blit_full(const uint8_t* buf)
{
    begin_window(0, PANEL_W-1, 0, (PANEL_H/8)-1);

    uint8_t line[PANEL_W];
    for (int p = 0; p < PANEL_H/8; ++p) {
        for (int x = 0; x < PANEL_W; ++x) {
            uint8_t b = 0;
            for (int bit = 0; bit < 8; ++bit) {
                int y = p*8 + bit;
                int idx = y*PANEL_W + x;
                uint8_t v = (buf[idx>>3] >> (7 - (idx & 7))) & 1u;
                b |= (uint8_t)(v << bit);
            }
            line[x] = b;
        }
        tx(line, PANEL_W, true);
    }
}

// ---- 64x64 centered blit (buf is 64x64) ----
void oled_blit64_center(const uint8_t* buf){
    enum{W = 64, H = 64};
    int offX = (PANEL_W - W)/2; if (offX<0) offX=0;
    int offY = (PANEL_H - H)/2; if (offY<0) offY=0;
    int pageStart = offY/8;

    begin_window(offX, offX + W - 1, pageStart, pageStart + (H/8) - 1);

    uint8_t line[W];
    for (int p=0; p<H/8; ++p){
        for (int x=0; x<W; ++x){
            uint8_t b=0;
            for (int bit=0; bit<8; ++bit){
                int y = p*8 + bit;
                int idx = y*W + x;
                uint8_t v = (buf[idx>>3] >> (7-(idx&7))) & 1u;
                b |= (uint8_t)(v << bit);
            }
            line[x]=b;
        }
        tx(line, W, true);
    }
}

// ---- 64x64 blit with horizontal offset (buf is 64x64) ----
void oled_blit64_offset(const uint8_t* buf, int xoff_px){
    enum { W = 64, H = 64 };
    int baseX = (PANEL_W - W)/2;
    int colStart = baseX + xoff_px;
    int colEnd   = colStart + W - 1;
    if (colEnd < 0 || colStart > (PANEL_W - 1)) return;

    int srcX0 = 0;
    if (colStart < 0) { srcX0 = -colStart; colStart = 0; }
    int drawW = W - srcX0;
    if (colEnd >= PANEL_W) { drawW -= (colEnd - (PANEL_W - 1)); colEnd = PANEL_W - 1; }
    if (drawW <= 0) return;

    int offY = (PANEL_H - H)/2;
    int pageStart = offY / 8;

    begin_window(colStart, colStart + drawW - 1, pageStart, pageStart + (H/8) - 1);

    uint8_t line[W];
    for (int p=0; p<H/8; ++p){
        for (int x=0; x<drawW; ++x){
            int sx = srcX0 + x;
            uint8_t b=0;
            for (int bit=0; bit<8; ++bit){
                int y = p*8 + bit;
                int idx = y*W + sx;
                uint8_t v = (buf[idx>>3] >> (7-(idx&7))) & 1u;
                b |= (uint8_t)(v << bit);
            }
            line[x]=b;
        }
        tx(line, drawW, true);
    }
}

// ---- Scroll curve used by the logo slide-out ----
#define SCROLL_TARGET (32 + 64 + 8)  // = 104 px: center(32) + width(64) + headroom(8)
#define KICK_RIGHT     10            // small right kick at the start
#define SPRING_DECAY   2.6f
#define SPRING_FREQ    0.90f

int oled_calc_scroll_px_slick(int step, int total_steps)
{
    if (total_steps < 2) return -SCROLL_TARGET;
    float t = (float)step / (float)(total_steps - 1);

    const float t1 = 0.18f;  // duration of the initial right-kick
    float x;

    if (t <= t1) {
        // ease out to a small positive offset
        float u = t / t1;
        u = 1.0f - (1.0f - u) * (1.0f - u);
        x = +KICK_RIGHT * u;
    } else {
        // spring back left past the left edge
        float u = (t - t1) / (1.0f - t1);
        float A = (float)SCROLL_TARGET + KICK_RIGHT;     // amplitude to clear screen
        float decay = expf(-SPRING_DECAY * u);
        float osc   = cosf(2.0f * (float)M_PI * SPRING_FREQ * u);
        x = +KICK_RIGHT - A * (1.0f - decay * osc);
    }

    if (x < -(float)SCROLL_TARGET) x = -(float)SCROLL_TARGET;
    return (int)floorf(x);
}

// ===== Simple 3-line text renderer =====
// ===== Simple 3-line text renderer =====
#include <string.h>

static const uint8_t font5x7[][5] = {
/* 0x20 ' ' */ {0x00,0x00,0x00,0x00,0x00},
/* 0x21 '!' */ {0x00,0x00,0x5F,0x00,0x00},
/* 0x22 '"' */ {0x00,0x07,0x00,0x07,0x00},
/* 0x23 '#' */ {0x14,0x7F,0x14,0x7F,0x14},
/* 0x24 '$' */ {0x24,0x2A,0x7F,0x2A,0x12},
/* 0x25 '%' */ {0x23,0x13,0x08,0x64,0x62},
/* 0x26 '&' */ {0x36,0x49,0x55,0x22,0x50},
/* 0x27 ''' */ {0x00,0x05,0x03,0x00,0x00},
/* 0x28 '(' */ {0x00,0x1C,0x22,0x41,0x00},
/* 0x29 ')' */ {0x00,0x41,0x22,0x1C,0x00},
/* 0x2A '*' */ {0x14,0x08,0x3E,0x08,0x14},
/* 0x2B '+' */ {0x08,0x08,0x3E,0x08,0x08},
/* 0x2C ',' */ {0x00,0x50,0x30,0x00,0x00},
/* 0x2D '-' */ {0x08,0x08,0x08,0x08,0x08},
/* 0x2E '.' */ {0x00,0x60,0x60,0x00,0x00},
/* 0x2F '/' */ {0x20,0x10,0x08,0x04,0x02},
/* 0x30 '0' */ {0x3E,0x51,0x49,0x45,0x3E},
/* 0x31 '1' */ {0x00,0x42,0x7F,0x40,0x00},
/* 0x32 '2' */ {0x42,0x61,0x51,0x49,0x46},
/* 0x33 '3' */ {0x21,0x41,0x45,0x4B,0x31},
/* 0x34 '4' */ {0x18,0x14,0x12,0x7F,0x10},
/* 0x35 '5' */ {0x27,0x45,0x45,0x45,0x39},
/* 0x36 '6' */ {0x3C,0x4A,0x49,0x49,0x30},
/* 0x37 '7' */ {0x01,0x71,0x09,0x05,0x03},
/* 0x38 '8' */ {0x36,0x49,0x49,0x49,0x36},
/* 0x39 '9' */ {0x06,0x49,0x49,0x29,0x1E},
/* 0x3A ':' */ {0x00,0x36,0x36,0x00,0x00},
/* 0x3B ';' */ {0x00,0x56,0x36,0x00,0x00},
/* 0x3C '<' */ {0x08,0x14,0x22,0x41,0x00},
/* 0x3D '=' */ {0x14,0x14,0x14,0x14,0x14},
/* 0x3E '>' */ {0x00,0x41,0x22,0x14,0x08},
/* 0x3F '?' */ {0x02,0x01,0x51,0x09,0x06},
/* 0x40 '@' */ {0x32,0x49,0x79,0x41,0x3E},
/* 0x41 'A' */ {0x7E,0x11,0x11,0x11,0x7E},
/* 0x42 'B' */ {0x7F,0x49,0x49,0x49,0x36},
/* 0x43 'C' */ {0x3E,0x41,0x41,0x41,0x22},
/* 0x44 'D' */ {0x7F,0x41,0x41,0x22,0x1C},
/* 0x45 'E' */ {0x7F,0x49,0x49,0x49,0x41},
/* 0x46 'F' */ {0x7F,0x09,0x09,0x09,0x01},
/* 0x47 'G' */ {0x3E,0x41,0x49,0x49,0x7A},
/* 0x48 'H' */ {0x7F,0x08,0x08,0x08,0x7F},
/* 0x49 'I' */ {0x00,0x41,0x7F,0x41,0x00},
/* 0x4A 'J' */ {0x20,0x40,0x41,0x3F,0x01},
/* 0x4B 'K' */ {0x7F,0x08,0x14,0x22,0x41},
/* 0x4C 'L' */ {0x7F,0x40,0x40,0x40,0x40},
/* 0x4D 'M' */ {0x7F,0x02,0x0C,0x02,0x7F},
/* 0x4E 'N' */ {0x7F,0x04,0x08,0x10,0x7F},
/* 0x4F 'O' */ {0x3E,0x41,0x41,0x41,0x3E},
/* 0x50 'P' */ {0x7F,0x09,0x09,0x09,0x06},
/* 0x51 'Q' */ {0x3E,0x41,0x51,0x21,0x5E},
/* 0x52 'R' */ {0x7F,0x09,0x19,0x29,0x46},
/* 0x53 'S' */ {0x46,0x49,0x49,0x49,0x31},
/* 0x54 'T' */ {0x01,0x01,0x7F,0x01,0x01},
/* 0x55 'U' */ {0x3F,0x40,0x40,0x40,0x3F},
/* 0x56 'V' */ {0x1F,0x20,0x40,0x20,0x1F},
/* 0x57 'W' */ {0x3F,0x40,0x38,0x40,0x3F},
/* 0x58 'X' */ {0x63,0x14,0x08,0x14,0x63},
/* 0x59 'Y' */ {0x07,0x08,0x70,0x08,0x07},
/* 0x5A 'Z' */ {0x61,0x51,0x49,0x45,0x43},
/* 0x5B '[' */ {0x02,0x04,0x08,0x10,0x20},
/* 0x5C '\' */ {0x00,0x41,0x41,0x7F,0x00},
/* 0x5D ']' */ {0x04,0x02,0x01,0x02,0x04},
/* 0x5E '^' */ {0x04,0x02,0x01,0x02,0x04},
/* 0x5F '_' */ {0x40,0x40,0x40,0x40,0x40},
/* 0x60 '`' */ {0x00,0x01,0x02,0x04,0x00},
/* 0x61 'a' */ {0x20,0x54,0x54,0x54,0x78},
/* 0x62 'b' */ {0x7F,0x48,0x44,0x44,0x38},
/* 0x63 'c' */ {0x38,0x44,0x44,0x44,0x20},
/* 0x64 'd' */ {0x38,0x44,0x44,0x48,0x7F},
/* 0x65 'e' */ {0x38,0x54,0x54,0x54,0x18},
/* 0x66 'f' */ {0x08,0x7E,0x09,0x01,0x02},
/* 0x67 'g' */ {0x0C,0x52,0x52,0x52,0x3E},
/* 0x68 'h' */ {0x7F,0x08,0x04,0x04,0x78},
/* 0x69 'i' */ {0x00,0x44,0x7D,0x40,0x00},
/* 0x6A 'j' */ {0x20,0x40,0x44,0x3D,0x00},
/* 0x6B 'k' */ {0x7F,0x10,0x28,0x44,0x00},
/* 0x6C 'l' */ {0x00,0x41,0x7F,0x40,0x00},
/* 0x6D 'm' */ {0x7C,0x04,0x18,0x04,0x78},
/* 0x6E 'n' */ {0x7C,0x08,0x04,0x04,0x78},
/* 0x6F 'o' */ {0x38,0x44,0x44,0x44,0x38},
/* 0x70 'p' */ {0x7C,0x14,0x14,0x14,0x08},
/* 0x71 'q' */ {0x08,0x14,0x14,0x14,0x7C},
/* 0x72 'r' */ {0x7C,0x08,0x04,0x04,0x08},
/* 0x73 's' */ {0x48,0x54,0x54,0x54,0x20},
/* 0x74 't' */ {0x04,0x3F,0x44,0x40,0x20},
/* 0x75 'u' */ {0x3C,0x40,0x40,0x20,0x7C},
/* 0x76 'v' */ {0x1C,0x20,0x40,0x20,0x1C},
/* 0x77 'w' */ {0x3C,0x40,0x30,0x40,0x3C},
/* 0x78 'x' */ {0x44,0x28,0x10,0x28,0x44},
/* 0x79 'y' */ {0x0C,0x50,0x50,0x50,0x3C},
/* 0x7A 'z' */ {0x44,0x64,0x54,0x4C,0x44},
/* 0x7B '{' */ {0x00,0x08,0x36,0x41,0x00},
/* 0x7C '|' */ {0x00,0x00,0x7F,0x00,0x00},
/* 0x7D '}' */ {0x00,0x41,0x36,0x08,0x00},
/* 0x7E '~' */ {0x08,0x04,0x08,0x10,0x08},
};

static inline void _pset(uint8_t *b,int x,int y){
    if ((unsigned)x>=PANEL_W||(unsigned)y>=PANEL_H) return;
    int idx = y*PANEL_W + x;
    b[idx>>3] |= (uint8_t)(1u << (7 - (idx & 7)));
}

static inline void _buf_clear(uint8_t *b){ memset(b,0,(PANEL_W*PANEL_H)/8); }

static void _draw_char(uint8_t *b,int x,int y,char c){
    if (c < 32 || c > 126) c = ' ';                  // full printable ASCII range
    const uint8_t *col = font5x7[(unsigned char)c - 32];
    for (int i=0;i<5;i++){
        uint8_t bits = col[i];
        for (int r=0;r<7;r++){
            if (bits & (1u<<r)) _pset(b, x+i, y+r);  // bit0 = top pixel
        }
    }
}

static void _draw_text(uint8_t *b,int x,int y,const char* s){
    int cx=x;
    for (; *s; ++s){
        if (cx+5 > PANEL_W) break;
        _draw_char(b, cx, y, *s);
        cx += 6;                                     // 1px spacing
    }
}


void oled_render_three_lines(const char* a, const char* b, const char* c){
    static uint8_t g[PANEL_W * PANEL_H / 8];
    _buf_clear(g);
    const int y1=10, y2=28, y3=46;
    int len1=strlen(a), len2=strlen(b), len3=strlen(c);
    int x1=(PANEL_W - len1*6 + 1)/2; if (x1<0)x1=0;
    int x2=(PANEL_W - len2*6 + 1)/2; if (x2<0)x2=0;
    int x3=(PANEL_W - len3*6 + 1)/2; if (x3<0)x3=0;
    _draw_text(g, x1, y1, a);
    _draw_text(g, x2, y2, b);
    _draw_text(g, x3, y3, c);
    oled_blit_full(g);
}

// ---- Tiny 3x5 text helper ----
typedef struct {
    char ch;
    uint8_t rows[5]; // 3-bit wide glyph
} glyph3x5_t;

static const uint8_t kFont3x5_digits[10][5] = {
    {0x7,0x5,0x5,0x5,0x7}, //0
    {0x2,0x6,0x2,0x2,0x7}, //1
    {0x7,0x1,0x7,0x4,0x7}, //2
    {0x7,0x1,0x7,0x1,0x7}, //3
    {0x5,0x5,0x7,0x1,0x1}, //4
    {0x7,0x4,0x7,0x1,0x7}, //5
    {0x7,0x4,0x7,0x5,0x7}, //6
    {0x7,0x1,0x1,0x1,0x1}, //7
    {0x7,0x5,0x7,0x5,0x7}, //8
    {0x7,0x5,0x7,0x1,0x1}, //9
};

// Minimal uppercase set for 3x5 glyphs
static const glyph3x5_t kFont3x5_alpha[] = {
    {'A',{0x7,0x5,0x7,0x5,0x5}},
    {'B',{0x6,0x5,0x6,0x5,0x6}},
    {'C',{0x7,0x4,0x4,0x4,0x7}},
    {'D',{0x6,0x5,0x5,0x5,0x6}},
    {'E',{0x7,0x4,0x7,0x4,0x7}},
    {'F',{0x7,0x4,0x7,0x4,0x4}},
    {'G',{0x3,0x4,0x5,0x5,0x3}},
    {'H',{0x5,0x5,0x7,0x5,0x5}},
    {'I',{0x7,0x2,0x2,0x2,0x7}},
    {'J',{0x3,0x1,0x1,0x5,0x2}},
    {'K',{0x5,0x6,0x4,0x6,0x5}},
    {'L',{0x4,0x4,0x4,0x4,0x7}},
    {'M',{0x5,0x7,0x7,0x5,0x5}},
    {'N',{0x5,0x7,0x7,0x7,0x5}},
    {'O',{0x7,0x5,0x5,0x5,0x7}},
    {'P',{0x7,0x5,0x7,0x4,0x4}},
    {'Q',{0x7,0x5,0x5,0x7,0x3}},
    {'R',{0x7,0x5,0x7,0x5,0x5}},
    {'S',{0x7,0x4,0x7,0x1,0x7}},
    {'T',{0x7,0x2,0x2,0x2,0x2}},
    {'U',{0x5,0x5,0x5,0x5,0x7}},
    {'V',{0x5,0x5,0x5,0x5,0x2}},
    {'W',{0x5,0x5,0x7,0x7,0x5}},
    {'X',{0x5,0x5,0x2,0x5,0x5}},
    {'Y',{0x5,0x5,0x2,0x2,0x2}},
    {'Z',{0x7,0x1,0x2,0x4,0x7}},
    {'-',{0x0,0x0,0x7,0x0,0x0}},
    {' ',{0x0,0x0,0x0,0x0,0x0}},
    {':',{0x0,0x2,0x0,0x2,0x0}},
    {'*',{0x0,0x5,0x2,0x5,0x0}},
    {'.',{0x0,0x0,0x0,0x0,0x2}},
    {',',{0x0,0x0,0x0,0x2,0x4}},
    {'!',{0x2,0x2,0x2,0x0,0x2}},
    {'?',{0x7,0x1,0x2,0x0,0x2}},
    {'/',{0x1,0x1,0x2,0x4,0x4}},
    {'>',{0x4,0x2,0x1,0x2,0x4}},
    {'<',{0x1,0x2,0x4,0x2,0x1}},
    {'=',{0x0,0x7,0x0,0x7,0x0}},
};

static const uint8_t kFont3x5_space[5] = {0,0,0,0,0};

static const uint8_t* glyph3x5_for(char c){
    if (c >= 'a' && c <= 'z') c = (char)(c - 'a' + 'A');
    if (c >= '0' && c <= '9') return kFont3x5_digits[c - '0'];
    for (size_t i = 0; i < sizeof(kFont3x5_alpha)/sizeof(kFont3x5_alpha[0]); ++i){
        if (kFont3x5_alpha[i].ch == c) return kFont3x5_alpha[i].rows;
    }
    return kFont3x5_space; // fallback to blank
}

void oled_draw_text3x5(uint8_t *fb, int x, int y, const char *text){
    if (!fb || !text) return;
    for (const char *p = text; *p; ++p){
        const uint8_t *rows = glyph3x5_for(*p);
        for (int dy = 0; dy < 5; ++dy){
            uint8_t bits = rows[dy];
            for (int dx = 0; dx < 3; ++dx){
                if (bits & (1u << (2 - dx))) _pset(fb, x + dx, y + dy);
            }
        }
        x += 4;
    }
}
